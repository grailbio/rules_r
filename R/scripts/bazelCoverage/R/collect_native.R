# Copyright 2018 The Bazel Authors.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' Collect native coverage data, to be found in \code{"*.gcda"} files.
#'
#' The ' \code{"*.gcda"}, along with the \code{"*.gcno"} files generated at
#' compile ' time, are read using the \code{gcov} command-line utility.  The
#' resulting ' files, in the GCOV format, are subsequently converted to the LCOV
#' format.
#'
#' @param cfg The configuration object.
#' @return A character vector of LCOV-formatted lines.
collect_native_coverage <- function(cfg) {
  dir.create(cfg$native_working_dir)

  log("gcda files (native code coverage):\n  ",
      paste(collapse="\n  ",
            list.files(path = cfg$gcda_dir,
                       pattern = "\\.gcda$",
                       recursive = TRUE,
                       full.names = TRUE,
                       all.files = TRUE)))

  # gcno files are found in two places: for cc_library dependencies,
  # in the `COVERAGE_MANIFEST` file (list of instrumented files);
  # for code generated by `R CMD INSTALL`, in the runfiles directory.
  cc_library_gcno_files <- grep("\\.gcno$",
                                readLines(cfg$coverage_manifest_file),
                                value = TRUE)
  cc_library_gcno_prefix <- cfg$exec_root
  r_gcno_files <- list.files(cfg$runfiles_dir,
                             recursive = TRUE,
                             pattern = "\\.gcno$",
                             all.files = TRUE)
  r_gcno_prefix <- cfg$runfiles_dir
  log("gcno files (native code coverage):\n",
      "  cc_library:\n    ",
      paste(collapse="\n    ", file.path(cc_library_gcno_prefix,
                                         cc_library_gcno_files)),
      "  rules_r:\n    ",
      paste(collapse="\n    ", file.path(r_gcno_prefix, r_gcno_files)))
  gcno_files <- c(cc_library_gcno_files, r_gcno_files)

  # The gcno and gcda files need to be copied to a common location for
  # gcov to work.
  copy_native_coverage_files(rel_paths = cc_library_gcno_files,
                             gcno_root = cc_library_gcno_prefix,
                             cfg = cfg)
  copy_native_coverage_files(rel_paths = r_gcno_files,
                             gcno_root = r_gcno_prefix,
                             cfg = cfg)

  # gcov is run over each directory separately.  The reason we do not
  # run gcov on all the coverage files at the same time is that we
  # want to add some path information that is missing in the resulting
  # GCOV files.
  run_gcov <- function(src) {
    quiet <- !bazel_r_debug()
    out_path <- file.path(cfg$native_working_dir, dirname(src[[1]]))
    # -p: Preserve complete path information in the names of
    #     generated .gcov files ('/' translated to '#', '.' removed,
    #     unremovable '..' translated to '^').
    # -o: Object directory.
    args <- c(file.path(cfg$native_working_dir, src), "-p", "-o", out_path)
    withr::with_dir(out_path, {
      covr:::system_check(cfg$gcov_bin,
        args = args,
        quiet = quiet, echo = !quiet)
    })
  }
  tapply(gcno_files, dirname(gcno_files), run_gcov)

  # Gather the GCOV files generated by gcov.
  gcov_outputs <- list.files(cfg$native_working_dir,
                             pattern = "\\.gcov$",
                             recursive = TRUE,
                             all.files = TRUE)
  log("gcov files (gcno+gcda):\n  ",
      paste(collapse="\n  ", file.path(cfg$native_working_dir, gcov_outputs)))

  return (Reduce(function (acc, x) c(acc,
                                     parse_gcov(x,
                                                cfg$native_working_dir,
                                                cc_library_gcno_files)),
                 gcov_outputs,
                 NULL))
}

#' Copy native coverage files (gcno, gcda) to the working directory for
#' native coverage.
#'
#' As a result, in the working directory, a \code{"foo/bar.gcno"} file
#' tags along a \code{"foo/bar.gcda"} file.
#'
#' @param rel_paths Character vector of \code{"*.gcno"} paths relative to
#'                  \code{gcno_root}.
#' @param gcno_root Root directory of \code{"*.gcno"} files.
#' @param cfg The configuration object.
copy_native_coverage_files <- function(rel_paths, gcno_root, cfg) {
  for (cur in rel_paths) {
    # Create output directory
    dir.create(dirname(file.path(cfg$native_working_dir, cur)), recursive = TRUE, showWarnings = FALSE)

    # Copy gcno file
    src <- file.path(gcno_root, cur)
    file_copy(src, file.path(cfg$native_working_dir, cur))

    # Copy corresponding gcda if it exists
    gcda_rel <- sub("\\.gcno$", ".gcda", cur)
    gcda_src <- file.path(cfg$gcda_dir, gcda_rel)
    if (!file.exists(gcda_src) && grepl("_objs", gcda_rel, fixed = TRUE)) {
      # For native code, the gcno files are within an _objs directory,
      # but the gcda are in the gcda directory with the part leading to
      # the _objs directory stripped.
      gcda_src <- file.path(cfg$gcda_dir, gsub(".*/_objs/[^/]+/", "", gcda_rel))
    }
    if (!file.exists(gcda_src)) {
      log("gcno file with no matching gcda file:",
          "\n  gcno: ", src,
          "\n  gcda: ", gcda_src,
          "\n    -> cannot collect coverage")
    } else {
      file_copy(gcda_src, file.path(cfg$native_working_dir, gcda_rel))
    }
  }
}

#' Parse a GCOV-formatted file.
#'
#' This does not handle \code{LCOV_EXCL_START}, etc.
#'
#' @param rel_path Relative path of the GCOV file, relative to \code{root}.
#' @param root Root directory where to look up the GCOV file.
#' @return A character vector of LCOV lines, or \code{NULL} if the file is
#' ignored (e.g., it covers a system source file).
parse_gcov <- function(rel_path, root, cc_library_gcno_files) {
  # See https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html, option -p,
  # for the logic of the basename.
  if (startsWith(basename(rel_path), "#")) {
    # The source file was included using an absolute path, we assume
    # it is a system file and exclude it from coverage.
    return (NULL)
  }

  # We currently do not support '^' (translated from '../').
  if (grepl(fixed = TRUE, '^', rel_path)) {
    log("gcov files with a '^'-filename are currently not supported: ",
        file.path(root, rel_path))
    return (NULL)
  }

  lines <- readLines(file.path(root, rel_path))

  # Read line-by-line coverage
  re <- rex::rex(any_spaces,
    capture(name = "coverage", some_of(digit, "-", "#", "=")),
    ":", any_spaces,
    capture(name = "line", digits),
    ":"
  )
  matches <- rex::re_matches(lines, re)
  # Lines subject to code coverage have a numeric 'coverage' column,
  # which can be '0'.  Lines excluded from code coverage (e.g., they
  # are blank or contain only comments) have a '-' coverage column.
  coverage <- suppressWarnings(as.numeric(matches$coverage))
  if (all(is.na(coverage))) {
    return (NULL)
  }

  # Read the source file name from the GCOV file, and try to find the
  # real source path, relative to the exec root.  For instance,
  # if coverage data for a source file 'foo/bar/qux.c' is gathered in
  # 'wobble/foo/bar/foo#bar#qux.c.gcov", then the real source path is
  # 'wobble/foo/bar/qux.c' (and wobble was an include path).
  source_file <- rex::re_matches(lines[1],
                                 rex::rex("Source:",
                                          capture(name = "source",
                                                  anything)))$source
  dash_count <- length(strsplit(basename(rel_path), "#")[[1]])
  prefix <- strsplit(dirname(rel_path), "/")[[1]]
  prefix <- prefix[1:(length(prefix) - dash_count + 1)]
  source_file <- gsub("^\\./", "", source_file)
  if (length(prefix) > 0) {
    source_file <- paste0(paste(collapse = "/", prefix), "/", source_file)
  }
  if (sub("\\.[^.]+$", ".gcno", source_file) %in% cc_library_gcno_files ||
      sub("\\.[^.]+$", ".pic.gcno", source_file) %in% cc_library_gcno_files) {
    # For cc_library code coverage, we need a path relative to the _objs
    # directory.
    source_file <- gsub(".*/_objs/[^/]+/", "", source_file)
  }
  return (c(
    paste0("SF:", source_file),
    paste0("DA:",
           matches$line[!is.na(coverage)],  # Line number, starting from 1
           ",",
           coverage[!is.na(coverage)]),     # Hit count
    "end_of_record"))
}
