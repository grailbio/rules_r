/*
Copyright 2018 The Bazel Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package razel

import (
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
	bzl "github.com/bazelbuild/buildtools/build"
)

const (
	descFname        = "DESCRIPTION"
	buildIgnoreFname = ".Rbuildignore"
)

var (
	namespaceExpr = regexp.MustCompile("^NAMESPACE$")
	rdExpr        = regexp.MustCompile("^man$")
)

type rLang struct{}

func (rLang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"r_pkg": {
			MergeableAttrs: map[string]bool{
				"pkg_name": true, "srcs": true, "deps": true, "roclets_deps": true},
		},
		"r_library": {
			ResolveAttrs: map[string]bool{"pkgs": true},
		},
		"r_unit_test": {
			MergeableAttrs: map[string]bool{"suggested_deps": true},
			ResolveAttrs:   map[string]bool{"pkg": true},
		},
		"r_pkg_test": {
			MergeableAttrs: map[string]bool{"suggested_deps": true},
			ResolveAttrs:   map[string]bool{"pkg": true},
		},
	}
}

func (rLang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name: "@com_rules_r//R:defs.bzl",
			Symbols: []string{
				"r_pkg",
				"r_library",
				"r_unit_test",
				"r_pkg_test",
			},
		},
	}
}

func (rLang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	var res language.GenerateResult

	rCfg := getRConfig(args.Config)
	if !rCfg.generateRules {
		return res
	}

	// Need at least the DESCRIPTION file present and parseable.
	// Set of files in this directory.
	files := make(map[string]struct{})
	for _, f := range args.RegularFiles {
		files[f] = struct{}{}
	}
	if _, ok := files[descFname]; !ok {
		// Technically, we can delete any previous R rules left over here in error,
		// by setting them as Empty in res, but, to keep things simple, we decide
		// to not do it.
		return res
	}
	fields, err := parseDCFFromPath(path.Join(args.Dir, descFname))
	if err != nil {
		log.Print(err)
		return res
	}
	pkgName := strings.TrimSpace(fields["Package"])

	var hasTestsDir bool
	for _, d := range args.Subdirs {
		if d == "tests" {
			hasTestsDir = true
		}
	}

	var pkgRule, depsRule, suggestedDepsRule, libRule *rule.Rule
	var testRules, checkRules []*rule.Rule
	var labelName string
	var roclets StringSet
	if args.File != nil {
		for _, r := range args.File.Rules {
			if r.Kind() == "r_pkg" {
				if pkgRule != nil {
					log.Printf("multiple r_pkg rules found in %s", args.File.Path)
				}
				labelName = r.Name()
				pkgRule = rule.NewRule("r_pkg", labelName)
				// Also note which roclets are set; these will be useful later to
				// filter which source files will be collected from the filesystem, and
				// which will be generated by the roclets.
				roclets = make(StringSet)
				for _, r := range r.AttrStrings("roclets") {
					roclets[r] = struct{}{}
				}
			} else if r.Name() == "library" {
				libRule = rule.NewRule("r_library", "library")
			} else if r.Name() == "deps" {
				depsRule = rule.NewRule("r_library", "deps")
			} else if r.Name() == "suggested_deps" {
				suggestedDepsRule = rule.NewRule("r_library", "suggested_deps")
			} else if r.Kind() == "r_unit_test" && hasTestsDir {
				testRules = append(testRules, rule.NewRule("r_unit_test", r.Name()))
			} else if r.Kind() == "r_pkg_test" {
				checkRules = append(checkRules, rule.NewRule("r_pkg_test", r.Name()))
			}
		}
	}

	// If we did not find existing rules, create new rules and set some initial
	// attributes. The user is free to edit or delete these attributes and
	// gazelle won't revert them.
	if pkgRule == nil {
		labelName = path.Base(args.Rel)
		if labelName == "" {
			labelName = pkgName
		}
		pkgRule = rule.NewRule("r_pkg", labelName)
		pkgRule.SetAttr("visibility", []string{"//visibility:public"})
		roclets = rCfg.roclets
	}
	if depsRule == nil {
		depsRule = rule.NewRule("r_library", "deps")
		depsRule.SetAttr("tags", []string{"manual"})
	}
	if suggestedDepsRule == nil {
		suggestedDepsRule = rule.NewRule("r_library", "suggested_deps")
		suggestedDepsRule.SetAttr("tags", []string{"manual"})
	}
	if libRule == nil {
		libRule = rule.NewRule("r_library", "library")
		libRule.SetAttr("tags", []string{"manual"})
	}
	if len(testRules) == 0 && hasTestsDir {
		r := rule.NewRule("r_unit_test", "test")
		testRules = []*rule.Rule{r}
	}
	if len(checkRules) == 0 {
		r := rule.NewRule("r_pkg_test", "check")
		// Because we have the unit tests, we can keep the bigger package tests manual by default.
		r.SetAttr("tags", []string{"manual"})
		checkRules = []*rule.Rule{r}
	}

	// Always reset package name to the right package name.
	if labelName != pkgName {
		pkgRule.SetAttr("pkg_name", pkgName)
	}

	// Deps and roclets, for both existing and new rules.
	pkgRule.SetAttr("deps", []string{":deps"})
	if len(roclets) > 0 {
		pkgRule.SetAttr("roclets", roclets.Slice())
	}
	var rocletsDeps []string
	if len(pkgRule.AttrStrings("roclets")) > 0 {
		for dep := range rCfg.rocletsDeps {
			rocletsDeps = append(rocletsDeps, dep)
		}
		if rCfg.rocletsIncludePkgDeps {
			rocletsDeps = append(rocletsDeps, ":deps", ":suggested_deps")
		}
	}
	if len(rocletsDeps) > 0 {
		pkgRule.SetAttr("roclets_deps", rocletsDeps)
	}

	for _, r := range testRules {
		r.SetAttr("suggested_deps", []string{":suggested_deps"})
	}
	for _, r := range checkRules {
		r.SetAttr("suggested_deps", []string{":suggested_deps"})
	}

	res.Gen = []*rule.Rule{pkgRule, depsRule, suggestedDepsRule, libRule}
	if rCfg.addTestRules {
		res.Gen = append(res.Gen, testRules...)
		res.Gen = append(res.Gen, checkRules...)
	}

	// Package source files.
	// Source file lists that are excluded from package builds and installs.
	// See https://cran.r-project.org/doc/manuals/R-exts.html#Building-package-tarballs
	if rCfg.srcsUseGlobs {
		// For globs, we will have to rely on people manually syncing their
		// .Rbuildignore files with their glob expression, because converting
		// regular expression to glob is non-trivial.
		excludeGlobs := []string{}
		for _, buildFname := range args.Config.ValidBuildFileNames {
			if _, ok := files[buildFname]; ok {
				excludeGlobs = append(excludeGlobs, buildFname)
			}
		}
		if _, ok := rCfg.roclets["namespace"]; ok {
			excludeGlobs = append(excludeGlobs, "NAMESPACE")
		}
		if _, ok := rCfg.roclets["rd"]; ok {
			excludeGlobs = append(excludeGlobs, "man/**")
		}
		pkgRule.SetAttr("srcs", rule.GlobValue{Patterns: []string{"**"}, Excludes: excludeGlobs})
	} else {
		var ignoreFnames []string
		if _, ok := files[buildIgnoreFname]; ok {
			ignoreFnames = append(ignoreFnames, buildIgnoreFname)
		}
		srcFiles, err := listFiles(args.Dir, pkgName, ignoreFnames, args.Config.ValidBuildFileNames, roclets)
		if err != nil {
			log.Printf("could not list files in %q: %v", args.Dir, err)
			return res
		}
		pkgRule.SetAttr("srcs", srcFiles)
	}

	// Package dependencies.
	imports := pkgImports{
		pkgName:          pkgName,
		pkgDeps:          extractDeps(fields, []string{"Depends", "Imports", "LinkingTo"}, rCfg.installedPkgs, args.Dir),
		pkgSuggestedDeps: extractDeps(fields, []string{"Suggests"}, rCfg.installedPkgs, args.Dir),
	}
	// Need to set for each rule, which will need these for the resolve step.
	// Each rule only needs a subset, but no harm is sending the full object.
	// r_pkg: pkgDeps, pkgSuggestedDeps
	// r_library: pkgName
	// r_unit_test, r_pkg_test: pkgName, pkgSuggestedDeps
	for range res.Gen {
		res.Imports = append(res.Imports, imports)
	}
	return res
}

func (rLang) Fix(c *config.Config, f *rule.File) {
	if !c.ShouldFix {
		return
	}
	rCfg := getRConfig(c)
	if !rCfg.generateRules {
		return
	}
	// This is a rather nuclear option in which we delete the srcs
	// attributes for r_pkg because those are not easily merged and need to be
	// standardized, and delete any assignment statements for variables like
	// PKG_NAME, PKG_DEPS, PKG_SUGGESTED_DEPS, etc. which users could have used
	// to store such information in a common variable.
	for _, r := range f.Rules {
		if r.Kind() != "r_pkg" {
			continue
		}
		pkgName := pkgName(r, f)
		// We need to use the AttrDefn function from buildtools package because
		// Attr only gives the RHS expression which does not have the keep comments
		// for the overall assignment.
		var bzlRule *bzl.Rule
		for _, bzlR := range f.File.Rules("r_pkg") {
			if r.Name() == bzlR.Name() {
				bzlRule = bzlR
				break
			}
		}
		if bzlRule == nil || !rule.ShouldKeep(bzlRule.AttrDefn("srcs")) {
			// Delete if this is a glob expression and we want non-glob and vice-versa.
			if _, isGlob := r.Attr("srcs").(*bzl.CallExpr); isGlob != rCfg.srcsUseGlobs {
				r.DelAttr("srcs")
			}
		}
		if r.Name() == "" && (bzlRule == nil || !rule.ShouldKeep(bzlRule.AttrDefn("name"))) {
			r.SetAttr("name", &bzl.StringExpr{Value: pkgName})
		}
	}
	var stmts []bzl.Expr
	for _, stmt := range f.File.Stmt {
		var keep bool
		if rule.ShouldKeep(stmt) {
			keep = true
		} else if e, ok := stmt.(*bzl.AssignExpr); !ok {
			keep = true
		} else if lhs, ok := e.LHS.(*bzl.Ident); !ok {
			keep = true
		} else if _, ok := rCfg.deleteAsgnmts[lhs.Name]; !ok {
			keep = true
		}
		if keep {
			stmts = append(stmts, stmt)
		}
	}
	f.File.Stmt = stmts
	return
}

func extractDeps(fields map[string]string, depFieldNames []string, installedPkgs map[string]struct{}, pkgPath string) []string {
	depSet := make(map[string]struct{})
	for _, fieldName := range depFieldNames {
		if _, ok := fields[fieldName]; !ok {
			continue
		}
		fieldDeps, err := parseDeps(fields[fieldName])
		if err != nil {
			log.Printf("parsing %s from %q: %v", fieldName, pkgPath, err)
		}
		for _, dep := range fieldDeps {
			if dep == "R" {
				continue
			}
			if _, installed := installedPkgs[dep]; installed {
				continue
			}
			depSet[dep] = struct{}{}
		}
	}
	deps := make([]string, 0, len(depSet))
	for dep := range depSet {
		deps = append(deps, dep)
	}
	return deps
}

func pkgName(r *rule.Rule, f *rule.File) string {
	pkgNameAttr := r.Attr("pkg_name")
	if pkgNameAttr == nil {
		pkgNameAttr = r.Attr("name")
	}
	if pkgNameAttr == nil {
		return path.Base(f.Pkg)
	}
	switch e := pkgNameAttr.(type) {
	case *bzl.StringExpr:
		return e.Value
	case *bzl.Ident:
		varName := e.Name
		for _, stmt := range f.File.Stmt {
			if e, ok := stmt.(*bzl.AssignExpr); !ok {
				continue
			} else if lhs, ok := e.LHS.(*bzl.Ident); !ok {
				continue
			} else if lhs.Name != varName {
				continue
			} else if rhs, ok := e.RHS.(*bzl.StringExpr); !ok {
				continue
			} else {
				return rhs.Value
			}
		}
	}
	log.Printf("%s: unable to obtain R package name", f.Path)
	return ""
}

// See get_exclude_patterns() in src/library/tools/R/build.R.
var defaultExcludePatterns = []*regexp.Regexp{
	regexp.MustCompile("(^|/)(CVS|\\.svn|\\.arch-ids|\\.bzr|\\.git|\\.hg|_darcs|\\.metadata)(/|$)"),
	regexp.MustCompile("(^|/)\\.DS_Store$"),
	regexp.MustCompile("^\\.(RData|Rhistory)$"),
	regexp.MustCompile("~$"),
	regexp.MustCompile("\\.bak$"),
	regexp.MustCompile("\\.swp$"),
	regexp.MustCompile("(^|/)\\.#[^/]*$"),
	regexp.MustCompile("(^|/)#[^/]*#$"),
	regexp.MustCompile("\\.swp$"),
	regexp.MustCompile("^config\\.(cache|log|status)$"),
	regexp.MustCompile("(^|/)autom4te\\.cache$"),
	regexp.MustCompile("^src/.*\\.d$"),
	regexp.MustCompile("^src/Makedeps$"),
	regexp.MustCompile("^inst/doc/Rplots\\.(ps|pdf)$"),
}

// List all files to be included in the srcs attribute. ignoreFnames are the
// files to use for reading regular expressions of files to ignore, buildFnames
// are valid BUILD file names, and roclets are active roclets for this package.
func listFiles(dirPath, pkgName string, ignoreFnames, buildFnames []string, roclets map[string]struct{}) (
	srcFiles []string, err error) {

	dirPath = filepath.Clean(dirPath)
	var excludePatterns []*regexp.Regexp
	for _, ignoreFname := range ignoreFnames {
		pats, err := readExcludePatterns(filepath.Join(dirPath, ignoreFname))
		if err != nil {
			log.Print(err)
		}
		excludePatterns = append(excludePatterns, pats...)
	}
	// Ignore any source or binary archives for the package.
	if tarExp, err := regexp.Compile("^" + pkgName + "_[0-9.-]+\\.(tar\\.gz|tar|tar\\.bz2|tar\\.xz|tgz|zip)$"); err != nil {
		log.Print(err)
	} else {
		excludePatterns = append(excludePatterns, tarExp)
	}
	if _, ok := roclets["namespace"]; ok {
		excludePatterns = append(excludePatterns, namespaceExpr)
	}
	if _, ok := roclets["rd"]; ok {
		excludePatterns = append(excludePatterns, rdExpr)
	}
	excludePatterns = append(excludePatterns, defaultExcludePatterns...)

	shouldExclude := func(path string) bool {
		// Always retain the original ignore file.
		for _, ignoreFname := range ignoreFnames {
			if path == ignoreFname {
				return false
			}
		}
		for _, buildFname := range buildFnames {
			if path == buildFname {
				return true
			}
		}
		// Match with the exclude patterns.
		for _, pattern := range excludePatterns {
			if pattern.MatchString(path) {
				return true
			}
		}
		return false
	}
	err = filepath.Walk(dirPath,
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if strings.HasPrefix(path, dirPath+string(filepath.Separator)) {
				path = path[(len(dirPath) + 1):]
			}
			if shouldExclude(path) {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
			if !info.IsDir() {
				srcFiles = append(srcFiles, path)
			}
			return nil
		})
	return srcFiles, err
}
